"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.canTurtleBuildSdkVersion = exports.oldestSupportedMajorVersionAsync = exports.newestReleasedSdkVersionAsync = exports.parseSdkVersionFromTag = exports.lteSdkVersion = exports.gteSdkVersion = exports.releasedSdkVersionsAsync = exports.sdkVersionsAsync = exports.versionsAsync = void 0;
const getenv_1 = __importDefault(require("getenv"));
const pickBy_1 = __importDefault(require("lodash/pickBy"));
const path_1 = __importDefault(require("path"));
const semver_1 = __importDefault(require("semver"));
const internal_1 = require("./internal");
async function versionsAsync(options) {
    const api = new internal_1.ApiV2();
    const versionCache = new internal_1.FsCache.Cacher(() => api.getAsync('versions/latest'), 'versions.json', 0, path_1.default.join(__dirname, '../caches/versions.json'));
    // Clear cache when opting in to beta because things can change quickly in beta
    if (getenv_1.default.boolish('EXPO_BETA', false) || (options === null || options === void 0 ? void 0 : options.skipCache)) {
        versionCache.clearAsync();
    }
    return await versionCache.getAsync();
}
exports.versionsAsync = versionsAsync;
async function sdkVersionsAsync() {
    const { sdkVersions } = await versionsAsync();
    return sdkVersions;
}
exports.sdkVersionsAsync = sdkVersionsAsync;
// NOTE(brentvatne): it is possible for an unreleased version to be published to
// the versions endpoint, but in some cases we only want to list out released
// versions
async function releasedSdkVersionsAsync() {
    const sdkVersions = await sdkVersionsAsync();
    return pickBy_1.default(sdkVersions, (data, _sdkVersionString) => !!data.releaseNoteUrl || (getenv_1.default.boolish('EXPO_BETA', false) && data.beta));
}
exports.releasedSdkVersionsAsync = releasedSdkVersionsAsync;
function gteSdkVersion(expJson, sdkVersion) {
    if (!expJson.sdkVersion) {
        return false;
    }
    if (expJson.sdkVersion === 'UNVERSIONED') {
        return true;
    }
    try {
        return semver_1.default.gte(expJson.sdkVersion, sdkVersion);
    }
    catch (e) {
        throw new internal_1.XDLError('INVALID_VERSION', `${expJson.sdkVersion} is not a valid version. Must be in the form of x.y.z`);
    }
}
exports.gteSdkVersion = gteSdkVersion;
function lteSdkVersion(expJson, sdkVersion) {
    if (!expJson.sdkVersion) {
        return false;
    }
    if (expJson.sdkVersion === 'UNVERSIONED') {
        return false;
    }
    try {
        return semver_1.default.lte(expJson.sdkVersion, sdkVersion);
    }
    catch (e) {
        throw new internal_1.XDLError('INVALID_VERSION', `${expJson.sdkVersion} is not a valid version. Must be in the form of x.y.z`);
    }
}
exports.lteSdkVersion = lteSdkVersion;
function parseSdkVersionFromTag(tag) {
    if (tag.startsWith('sdk-')) {
        return tag.substring(4);
    }
    return tag;
}
exports.parseSdkVersionFromTag = parseSdkVersionFromTag;
// NOTE(brentvatne): it is possible for an unreleased version to be published to
// the versions endpoint, but in some cases we need to get the latest *released*
// version, not just the latest version.
async function newestReleasedSdkVersionAsync() {
    const betaOptInEnabled = getenv_1.default.boolish('EXPO_BETA', false);
    const sdkVersions = await sdkVersionsAsync();
    let result = null;
    let highestMajorVersion = '0.0.0';
    for (const [version, data] of Object.entries(sdkVersions)) {
        const hasReleaseNotes = !!data.releaseNoteUrl;
        const isBeta = !!data.beta;
        if (semver_1.default.major(version) > semver_1.default.major(highestMajorVersion) &&
            (hasReleaseNotes || (isBeta && betaOptInEnabled))) {
            highestMajorVersion = version;
            result = data;
        }
    }
    return {
        version: highestMajorVersion,
        data: result,
    };
}
exports.newestReleasedSdkVersionAsync = newestReleasedSdkVersionAsync;
async function oldestSupportedMajorVersionAsync() {
    const sdkVersions = await sdkVersionsAsync();
    const supportedVersions = pickBy_1.default(sdkVersions, v => !v.isDeprecated);
    const versionNumbers = Object.keys(supportedVersions).map(version => semver_1.default.major(version));
    return Math.min(...versionNumbers);
}
exports.oldestSupportedMajorVersionAsync = oldestSupportedMajorVersionAsync;
async function canTurtleBuildSdkVersion(sdkVersion, platform) {
    var _a;
    if (sdkVersion === 'UNVERSIONED') {
        return true;
    }
    if (semver_1.default.valid(sdkVersion) == null) {
        throw new internal_1.XDLError('INVALID_VERSION', `"${sdkVersion}" is not a valid version. Must be in the form of x.y.z`);
    }
    const supportedVersions = await getSdkVersionsSupportedByTurtle();
    const supportedVersionsForPlatform = (_a = supportedVersions[platform]) !== null && _a !== void 0 ? _a : [];
    return supportedVersionsForPlatform.indexOf(sdkVersion) !== -1;
}
exports.canTurtleBuildSdkVersion = canTurtleBuildSdkVersion;
async function getSdkVersionsSupportedByTurtle() {
    const api = new internal_1.ApiV2();
    return await api.getAsync('standalone-build/supportedSDKVersions');
}
//# sourceMappingURL=Versions.js.map