"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveNgrokAsync = void 0;
const PackageManager = __importStar(require("@expo/package-manager"));
const chalk_1 = __importDefault(require("chalk"));
const getenv_1 = __importDefault(require("getenv"));
// @ts-ignore
const requireg_1 = __importDefault(require("requireg"));
const resolve_from_1 = __importDefault(require("resolve-from"));
const semver_1 = __importDefault(require("semver"));
const internal_1 = require("../internal");
const NGROK_REQUIRED_VERSION = '^2.4.3';
const EXPO_DEBUG = getenv_1.default.boolish('EXPO_DEBUG', false);
let _ngrokInstance = null;
async function resolveNgrokAsync(projectRoot, { shouldPrompt = true, autoInstall = false, } = {}) {
    const ngrok = await findNgrokBinAsync(projectRoot);
    if (!ngrok) {
        const packageName = `@expo/ngrok@${NGROK_REQUIRED_VERSION}`;
        if (shouldPrompt) {
            if (!autoInstall) {
                // Delay the prompt so it doesn't conflict with other dev tool logs
                await internal_1.delayAsync(100);
            }
            const answer = autoInstall ||
                (await internal_1.Prompts.confirmAsync({
                    message: `The package ${packageName} is required to use tunnels, would you like to install it globally?`,
                    initial: true,
                }));
            if (answer) {
                internal_1.Logger.global.info(`Installing ${packageName} for ${chalk_1.default.bold `tunnel`} support...`);
                const packageManager = PackageManager.createForProject(projectRoot, {
                    silent: !EXPO_DEBUG,
                });
                try {
                    await packageManager.addGlobalAsync(packageName);
                    internal_1.Logger.global.info(`Successfully installed ${packageName}`);
                }
                catch (e) {
                    e.message = `Failed to install ${packageName} globally: ${e.message}`;
                    throw e;
                }
                return await resolveNgrokAsync(projectRoot, { shouldPrompt: false });
            }
        }
        throw new Error(`Please install ${packageName} and try again, or try using another hosting method like lan or localhost`);
    }
    return ngrok;
}
exports.resolveNgrokAsync = resolveNgrokAsync;
// Resolve a copy that's installed in the project.
async function resolvePackageFromProjectAsync(projectRoot) {
    try {
        const ngrokPackagePath = resolve_from_1.default(projectRoot, '@expo/ngrok/package.json');
        const pkg = require(ngrokPackagePath);
        if (pkg && semver_1.default.satisfies(pkg.version, NGROK_REQUIRED_VERSION)) {
            const ngrokPath = resolve_from_1.default(projectRoot, '@expo/ngrok');
            if (EXPO_DEBUG) {
                internal_1.Logger.global.info(`Resolving @expo/ngrok from project: "${ngrokPath}"`);
            }
            return require(ngrokPath);
        }
    }
    catch { }
    return null;
}
// Resolve a copy that's installed globally.
async function resolveGlobalPackageAsync() {
    try {
        // use true to disable the use of local packages.
        const pkg = requireg_1.default('@expo/ngrok/package.json', true);
        if (semver_1.default.satisfies(pkg.version, NGROK_REQUIRED_VERSION)) {
            if (EXPO_DEBUG) {
                internal_1.Logger.global.info(`Resolving global @expo/ngrok from: "${requireg_1.default.resolve('@expo/ngrok')}"`);
            }
            return requireg_1.default('@expo/ngrok', true);
        }
    }
    catch { }
    return null;
}
async function findNgrokBinAsync(projectRoot) {
    if (_ngrokInstance) {
        return _ngrokInstance;
    }
    const localInstance = await resolvePackageFromProjectAsync(projectRoot);
    if (localInstance) {
        _ngrokInstance = localInstance;
        return _ngrokInstance;
    }
    const globalInstance = await resolveGlobalPackageAsync();
    if (globalInstance) {
        _ngrokInstance = globalInstance;
        return _ngrokInstance;
    }
    return null;
}
//# sourceMappingURL=resolveNgrok.js.map