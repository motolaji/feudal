"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExpoLogFormatter = void 0;

function _xcpretty() {
  const data = require("@expo/xcpretty");

  _xcpretty = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _findUp() {
  const data = _interopRequireDefault(require("find-up"));

  _findUp = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _log() {
  const data = _interopRequireDefault(require("../../../log"));

  _log = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const ERROR = '❌ ';
const cachedPackages = {};

function packageJsonForPath(filePath) {
  const packageJson = _findUp().default.sync('package.json', {
    cwd: filePath
  });

  if (packageJson) {
    return require(packageJson);
  }

  return null;
}

function moduleNameFromPath(modulePath) {
  if (modulePath.startsWith('@')) {
    const [org, packageName] = modulePath.split('/');

    if (org && packageName) {
      return [org, packageName].join('/');
    }

    return modulePath;
  }

  const [packageName] = modulePath.split('/');
  return packageName ? packageName : modulePath;
}

function getNodeModuleName(filePath) {
  // '/Users/evanbacon/Documents/GitHub/lab/yolo5/node_modules/react-native-reanimated/ios/Nodes/REACallFuncNode.m'
  const [, modulePath] = filePath.split('/node_modules/');

  if (modulePath) {
    return moduleNameFromPath(modulePath);
  }

  return null;
}

class CustomParser extends _xcpretty().Parser {
  constructor(formatter) {
    super(formatter);
    this.formatter = formatter;

    _defineProperty(this, "isCollectingMetroError", false);

    _defineProperty(this, "metroError", []);
  }

  parse(text) {
    const results = this.checkMetroError(text);

    if (results) {
      return results;
    }

    return super.parse(text);
  } // Error for the build script wrapper in expo-updates that catches metro bundler errors.
  // This can be repro'd by importing a file that doesn't exist, then building.
  // Metro will fail to generate the JS bundle, and throw an error that should be caught here.


  checkMetroError(text) {
    // In expo-updates, we wrap the bundler script and add regex around the error message so we can present it nicely to the user.
    return (0, _xcpretty().switchRegex)(text, [[/@build-script-error-begin/m, () => {
      this.isCollectingMetroError = true;
    }], [/@build-script-error-end/m, () => {
      const results = this.metroError.join('\n'); // Reset the metro collection error array (should never need this).

      this.isCollectingMetroError = false;
      this.metroError = [];
      return this.formatter.formatMetroAssetCollectionError(results);
    }], [null, () => {
      // Collect all the lines in the metro build error
      if (this.isCollectingMetroError) {
        let results = text;

        if (!this.metroError.length) {
          const match = text.match(/Error loading assets JSON from Metro.*steps correctly.((.|\n)*)/m);

          if (match && match[1]) {
            results = match[1].trim();
          }
        }

        this.metroError.push(results);
      }
    }]]);
  }

}

class ExpoLogFormatter extends _xcpretty().Formatter {
  static logPrettyItem(message) {
    _log().default.log(`${_chalk().default.whiteBright`\u203A`} ${message}`);
  }

  constructor(props) {
    super(props);
    this.props = props;

    _defineProperty(this, "nativeProjectRoot", void 0);

    this.nativeProjectRoot = _path().default.join(props.projectRoot, 'ios');
    this.parser = new CustomParser(this);
  }

  formatMetroAssetCollectionError(errorContents) {
    const results = `\n${_chalk().default.red(ERROR + // Provide proper attribution.
    'Metro encountered an error:\n' + errorContents)}\n`;
    this.errors.push(results);
    return results;
  }

  shouldShowCompileWarning(filePath, lineNumber, columnNumber) {
    if (_log().default.isDebug) {
      return true;
    }

    return !filePath.match(/node_modules/) && !filePath.match(/\/ios\/Pods\//);
  }

  getFileOperationTitle(type) {
    switch (type) {
      case 'Analyze':
        return 'Analyzing';

      case 'GenerateDSYMFile':
        return `Generating debug`;

      case 'Ld':
        return 'Linking  ';

      case 'Libtool':
        return 'Packaging';

      case 'ProcessPCH':
        return 'Precompiling';

      case 'ProcessInfoPlistFile':
        return 'Preparing';

      case 'CodeSign':
        return 'Signing  ';

      case 'Touch':
        return 'Creating ';

      case 'CompileC':
      case 'CompileSwift':
      case 'CompileXIB':
      case 'CompileStoryboard':
        return 'Compiling';

      default:
        // Unknown file operation
        return '';
    }
  }

  formatFileOperation(props) {
    const title = this.getFileOperationTitle(props.type);
    const moduleNameTag = this.getPkgName(props.filePath, props.target);
    return _xcpretty().Formatter.format(title, [moduleNameTag, _xcpretty().Formatter.formatBreadCrumb(props.fileName, props.target, props.project)].filter(Boolean).join(' '));
  }

  formatPhaseScriptExecution(scriptName, target, project) {
    const moduleNameTag = this.getPkgName('', target);
    return _xcpretty().Formatter.format('Executing', [moduleNameTag, _xcpretty().Formatter.formatBreadCrumb(scriptName, target, project)].filter(Boolean).join(' '));
  }

  getPkgName(filePath, target) {
    let moduleName = getNodeModuleName(filePath);

    if (!moduleName) {
      if (target === this.props.appName || target === `Pods-${this.props.appName}`) {
        moduleName = '';
      } else if (target && target in knownPackages) {
        moduleName = knownPackages[target];
      } else {
        const pkg = this.packageJsonForProject(target);

        if (pkg) {
          moduleName = pkg.name;
        }
      }
    }

    return moduleName ? _chalk().default.cyan(`${moduleName}`) : null;
  }

  packageJsonForProject(project) {
    var _Object$values$;

    if (!project) {
      return null;
    }

    if (project in cachedPackages) {
      return cachedPackages[project];
    }

    const filePath = (_Object$values$ = Object.values(this.props.podfile[project] || {})[0]) !== null && _Object$values$ !== void 0 ? _Object$values$ : null;

    if (!filePath) {
      return null;
    }

    const pkg = packageJsonForPath(_path().default.join(this.nativeProjectRoot, filePath));

    if (pkg) {
      cachedPackages[project] = pkg;
    }

    return pkg !== null && pkg !== void 0 ? pkg : null;
  }

  finish() {
    _log().default.log(`\n\u203A ${this.errors.length} error(s), and ${this.warnings.length} warning(s)\n`);
  }

} // A list of packages that aren't linked through cocoapods directly.


exports.ExpoLogFormatter = ExpoLogFormatter;
const knownPackages = {
  // Added to ReactCore as a `resource_bundle`
  'React-Core-AccessibilityResources': 'react-native',
  YogaKit: 'react-native',
  // flipper
  'Flipper-DoubleConversion': 'react-native',
  'Flipper-Folly': 'react-native',
  'OpenSSL-Universal': 'react-native',
  FlipperKit: 'react-native',
  Flipper: 'react-native',
  'Flipper-RSocket': 'react-native'
};
//# sourceMappingURL=ExpoLogFormatter.js.map